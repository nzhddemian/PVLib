// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios16.4-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name PVLib
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Accelerate
import CoreGraphics
import CoreImage
import CoreML
import CoreMedia
import Foundation
import ImageIO
import Metal
import MetalKit
import ModelIO
@_exported import PVLib
import Photos
import SceneKit
import Swift
import SwiftUI
import UIKit
import Vision
import _Concurrency
import _PhotosUI_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
import simd
@objc public class APlayer : ObjectiveC.NSObject, AVFAudio.AVAudioPlayerDelegate {
  public var url: Foundation.URL?
  public var timer: Foundation.Timer!
  public var player: AVFAudio.AVAudioPlayer
  public var itemTime: CoreMedia.CMTime!
  public var startTime: CoreMedia.CMTime
  public var loopInt: Swift.Int
  public var trackEnd: Swift.Double!
  public var trackStart: Swift.Double
  final public let asset: AVFoundation.AVAsset?
  public init(url: Foundation.URL)
  @objc public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
  public func update(comp: @escaping () -> ())
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AudioWriter : ObjectiveC.NSObject, AVFAudio.AVAudioRecorderDelegate {
  public func setup_recorder()
  public func startRec()
  public func pause()
  public func resume()
  public func stopRec()
  @objc override dynamic public init()
  @objc deinit
}
public protocol VAssetRaderDelegate {
  func seekTo(time: CoreMedia.CMTime)
  func readBuffer() -> CoreVideo.CVPixelBuffer?
  func playAsset()
  func pauseAsset()
  func setTimeRange(_ timeRange: CoreMedia.CMTimeRange)
}
public class VAssetReader : PVLib.VAssetRaderDelegate {
  public var sound: PVLib.Sound!
  weak public var delegate: (any PVLib.PBufferDelegate)?
  public var isTrimming: Swift.Bool
  public var asset: AVFoundation.AVAsset!
  public var player: AVFoundation.AVPlayer?
  public var playerItem: AVFoundation.AVPlayerItem!
  public var timeRange: CoreMedia.CMTimeRange
  public var pixelBuffer: CoreVideo.CVPixelBuffer?
  public var stopOp: Swift.Bool {
    get
    set(val)
  }
  public init(_ url: Foundation.URL)
  public func turnOnSound(_ isOn: Swift.Bool)
  public func seekTuStart()
  public func seekTo(time: CoreMedia.CMTime)
  public func playAsset()
  public func pauseAsset()
  public func setTimeRange(_ timeRange: CoreMedia.CMTimeRange)
  public func readBuffer() -> CoreVideo.CVPixelBuffer?
  @objc deinit
}
public class Node {
  public var mesh: MetalKit.MTKMesh?
  public var texture: (any Metal.MTLTexture)?
  public var transform: simd.simd_float4x4
  public var worldTransform: simd.simd_float4x4 {
    get
  }
  weak public var parentNode: PVLib.Node?
  public init()
  public init(mesh: MetalKit.MTKMesh)
  public func addChildNode(_ node: PVLib.Node)
  public func removeFromParent()
  @objc deinit
}
public struct AudioTrack {
  public var url: Foundation.URL
  public var timeRange: CoreMedia.CMTimeRange?
}
public struct SoundPlay {
  public var atTime: CoreMedia.CMTime
  public var track: PVLib.Sound
}
@_hasMissingDesignatedInitializers public class MusicSound {
  public static var loopsNumber: Swift.Int
  public static var camUrl: Foundation.URL!
  public static var editUrl: [Foundation.URL]
  public static var timeRange: CoreMedia.CMTimeRange!
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Audio {
  public static var track: PVLib.AudioTrack?
  public static var trimmedTracks: [PVLib.AudioTrack]
  public static var durationTrim: CoreMedia.CMTime!
  public static var camTrackUrl: Foundation.URL?
  public static var camTrackID: Swift.String?
  public static var editTrackUrl: Foundation.URL?
  public static var camTrackRange: CoreMedia.CMTimeRange?
  public static func fromVideo(inUrl: Foundation.URL, outUrl: Foundation.URL, callBack: @escaping () -> Swift.Void)
  public static func renderMusicSound(inUrl: Foundation.URL, toUrl: inout Foundation.URL, callBack: @escaping () -> Swift.Void)
  public static func trimmSound(inUrl: Foundation.URL?, outUrl: Foundation.URL, timeRange: CoreMedia.CMTimeRange?, callBack: @escaping () -> Swift.Void)
  @objc deinit
}
public enum ARMask : Swift.String, Swift.CaseIterable {
  case none, matrix, hypno, hole, eyes, glitch, stickers, tattoo, pixels, mustage
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.ARMask]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.ARMask] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum BeautyFilters : Swift.String, Swift.CaseIterable {
  case none, skin_smooth, makeup, eyes, oval, lips
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.BeautyFilters]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.BeautyFilters] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum CamFXs : Swift.String, Swift.CaseIterable {
  case none, misted_draw, white_stripes, lens, glitch, kaleidoscope, rgb_displace, rgb_wiggle, color_rects, under_water, negative, yb_wiggle, color_trails, burn, vhs
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.CamFXs]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.CamFXs] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum EditFXs : Swift.String, Swift.CaseIterable {
  case none, white_stripes, lens, glitch, kaleidoscope, rgb_displace, rgb_wiggle, color_rects, under_water, negative, yb_wiggle, color_trails, burn, vhs
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.EditFXs]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.EditFXs] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum MultiPassFXs : Swift.String, Swift.CaseIterable {
  case none, misted_draw, color_trails, burn, vhs
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.MultiPassFXs]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.MultiPassFXs] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum CamEffectType : Swift.String, Swift.CaseIterable {
  case pv_luts, pv_beauty, pv_masks, pv_particles, pv_effects
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.CamEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.CamEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum MainTools : Swift.String, Swift.CaseIterable {
  case manual, body, retouch, forms, filters, adjust, text, background
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.MainTools]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.MainTools] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum LayerTypes : Swift.String, Swift.CaseIterable {
  case none, fire, rain, matrix, fog, glitters, snow
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.LayerTypes]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.LayerTypes] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public var reshapeToolType: [Swift.String]
extension Swift.RawRepresentable where Self : Swift.CaseIterable {
  public static var allValues: [Self.RawValue] {
    get
  }
}
public enum MainVideoEditingTools : Swift.String, Swift.CaseIterable {
  case music, text, gif, layer, luts, fx
  public init?(rawValue: Swift.String)
  public typealias AllCases = [PVLib.MainVideoEditingTools]
  public typealias RawValue = Swift.String
  public static var allCases: [PVLib.MainVideoEditingTools] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct BeautyValues {
  public var skinSmoothing: Swift.Float
  public var makeUp: Swift.Float
  public var eyesDistortIntensity: Swift.Float
  public var lipsDistortIntensity: Swift.Float
  public var faceDistortIntensity: Swift.Float
  public var nosePoint: simd.float2
  public var lipsPoint: simd.float2
  public var eyesPoints: simd.float4
  public var cheeksPoints: simd.float4
}
public struct MetalUniforms {
  public var u_time: Swift.Float
  public var i_mouse: simd.float2
  public var p_mouse: simd.float2
  public var lutIntensity: Swift.Float
  public var brushSize: Swift.Float
  public var res: simd.float2
  public var frontCam: Swift.Bool
  public var rotation: Swift.Float
  public var rotationGif: Swift.Float
  public var cameraFront: Swift.Bool
}
public struct FaceDistortionPoints {
  public var eyesPoints: simd.float4
  public var cheeksPoints: simd.float4
  public var lipsPoint: simd.float2
}
public struct PVFaceScene {
  public init()
  public var faceGeometry: SceneKit.SCNGeometry?
  public var faceProjectionMatrix: SceneKit.SCNMatrix4
  public var faceDistortionPoint: PVLib.FaceDistortionPoints
  public var centerTransform: simd.simd_float4x4
  public var faceDetected: Swift.Bool
}
public protocol PVFaceSceneDelegate : AnyObject {
  func updateFaceMesh(front: CoreVideo.CVPixelBuffer, sceneView: SceneKit.SCNView) -> PVLib.PVFaceScene
}
extension Foundation.NSNotification.Name {
  public static let pvRemoveTextureWriter: Foundation.NSNotification.Name
}
extension Foundation.NSNotification.Name {
  public static let pvResumeTextureWriter: Foundation.NSNotification.Name
}
public class PVVCoordinator {
  public static var navigation: UIKit.UINavigationController!
  @objc deinit
  public static func resumeSession()
  public static func stopSession()
  public static var inBackground: Swift.Bool
  public static func shareImage(_ img: UIKit.UIImage)
  public static func start(from: QuartzCore.CATransitionSubtype, type: QuartzCore.CATransitionType, duration: CoreFoundation.CGFloat = 0.25, _ view: SwiftUI.AnyView, shouldRotate: Swift.Bool = false)
  public static func moveToSUIView(from: QuartzCore.CATransitionSubtype, type: QuartzCore.CATransitionType, duration: CoreFoundation.CGFloat = 0.25, _ view: SwiftUI.AnyView, shouldRotate: Swift.Bool = false)
  public static func moveToUIKitView(from: QuartzCore.CATransitionSubtype, type: QuartzCore.CATransitionType, duration: CoreFoundation.CGFloat = 0.25, _ viewController: UIKit.UIViewController)
  required public init(navigationController: UIKit.UINavigationController)
}
public class MetalVideoRecorder {
  public var writerer: AVFoundation.AVAssetWriter!
  public var isWriting: Swift.Bool
  public var started: Swift.Bool
  public init(size: CoreFoundation.CGSize)
  @objc deinit
  public func setupVideoWriter()
  public func start(_ time: CoreMedia.CMTime)
  public func end(_ time: CoreMedia.CMTime)
  public func flushTexture(mtlTexture: (any Metal.MTLTexture)?, recTime: CoreMedia.CMTime, failureComp: @escaping () -> ())
  public func finishRec(comp: @escaping () -> ())
}
extension AVFoundation.AVPlayer {
  public var isPlaying: Swift.Bool {
    get
  }
}
extension Foundation.URL {
  public func removeIfExists()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func removeSubviews()
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) public func image() -> UIKit.UIImage
}
extension simd.simd_float4x4 {
  public init(scaleBy s: Swift.Float)
  public init(rotationAbout axis: simd.float3, by angleRadians: Swift.Float)
  public init(translationBy t: simd.float3)
  public init(perspectiveProjectionFov fovRadians: Swift.Float, aspectRatio aspect: Swift.Float, nearZ: Swift.Float, farZ: Swift.Float)
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) public func leftTransition(_ controller: UIKit.UIViewController)
}
extension UIKit.UIColor {
  public static var playU: UIKit.UIColor
}
extension Photos.PHAssetCollection {
  public func isCameraRollAlbum() -> Swift.Bool
  public func savee(videoURL: Foundation.URL, completion: @escaping (Foundation.URL?, Swift.String?) -> ())
  public class func getAlbumm(title: Swift.String, completionHandler: @escaping (Photos.PHAssetCollection?) -> ())
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func createImage() -> UIKit.UIImage
}
extension Metal.MTLTexture {
  public func getColor(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, aspect: CoreFoundation.CGFloat) -> simd.float3?
  public func getData() -> Foundation.Data?
}
extension Metal.MTLTexture {
  public func toUIImage() -> UIKit.UIImage?
}
extension UIKit.UIImage {
  public func saveTo(url: Foundation.URL, name: Swift.String)
}
extension Foundation.URL {
  public static func getURL(item: _PhotosUI_SwiftUI.PhotosPickerItem, completionHandler: @escaping (_ result: Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  public static func getDocumentsDirectory() -> Foundation.URL
  public func cleanDir()
  public func removeIfExist()
}
extension Foundation.NSNotification.Name {
  public static let previewReady: Foundation.NSNotification.Name
  public static let finalRenderingDone: Foundation.NSNotification.Name
}
extension CoreFoundation.CGPoint {
  public func norm(inRect: CoreFoundation.CGRect) -> simd.float2
  public func nrm(inRect: CoreFoundation.CGRect) -> simd.float2
}
public struct DeviceRotationViewModifier : SwiftUI.ViewModifier {
  @_Concurrency.MainActor(unsafe) public func body(content: PVLib.DeviceRotationViewModifier.Content) -> some SwiftUI.View
  
  public typealias Body = @_opaqueReturnTypeOf("$s5PVLib26DeviceRotationViewModifierV4body7contentQr7SwiftUI01_dE8_ContentVyACG_tF", 0) __
}
extension SwiftUI.View {
  public func onRotate(perform action: @escaping (UIKit.UIDeviceOrientation) -> Swift.Void) -> some SwiftUI.View
  
}
public enum FrameAlignment {
  case top, bottom, leading, trailing
  public static func == (a: PVLib.FrameAlignment, b: PVLib.FrameAlignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftUI.View {
  public func alignment(_ alignment: PVLib.FrameAlignment) -> some SwiftUI.View
  
}
@_hasMissingDesignatedInitializers public class VEDitorConst {
  public static var playbackH: CoreFoundation.CGFloat
  public static var timeLineH: CoreFoundation.CGFloat
  @objc deinit
}
extension SwiftUI.Color {
  public static let gray_l: SwiftUI.Color
  public static let gray_n: SwiftUI.Color
  public static let gray_d: SwiftUI.Color
  public static let app_purple: SwiftUI.Color
  public static let app_violet: SwiftUI.Color
  public static let app_green: SwiftUI.Color
  public static let app_blue: SwiftUI.Color
  public static let myCustomColor3: SwiftUI.Color
}
extension UIKit.UIColor {
  public static let gray_l: UIKit.UIColor
  public static let gray_n: UIKit.UIColor
  public static let gray_d: UIKit.UIColor
  public static let app_purple: UIKit.UIColor
  public static let app_violet: UIKit.UIColor
  public static let app_green: UIKit.UIColor
  public static let app_blue: UIKit.UIColor
  public static let myCustomColor3: SwiftUI.Color
}
extension Swift.SIMD4 where Scalar == Swift.Float {
  public static let green_l: simd.float4
  public static let green_d: simd.float4
  public static let myCustomColor3: SwiftUI.Color
}
public struct BackgroundClearView : SwiftUI.UIViewRepresentable {
  public init()
  @_Concurrency.MainActor(unsafe) public func makeUIView(context: PVLib.BackgroundClearView.Context) -> UIKit.UIView
  @_Concurrency.MainActor(unsafe) public func updateUIView(_ uiView: UIKit.UIView, context: PVLib.BackgroundClearView.Context)
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = UIKit.UIView
}
extension CoreMedia.CMTime {
  public func frame(_ fps: Swift.Int) -> Swift.Int
}
extension AVFoundation.AVAsset {
  public func videoSize() -> CoreFoundation.CGSize
}
extension Swift.String {
  public func dateSTR() -> Swift.String
}
extension UIKit.UIColor {
  public static func randColor(seed: Swift.Int) -> UIKit.UIColor
  public static func seeded_rand(seed: Swift.Int, min: Swift.Double, max: Swift.Double) -> Swift.Int
}
public class WaveformImageDrawer {
  public init()
  public func waveformImage(fromAudioAt audioAssetURL: Foundation.URL, with configuration: PVLib.WaveformConfiguration, qos: Dispatch.DispatchQoS.QoSClass = .userInitiated, completionHandler: @escaping (_ waveformImage: UIKit.UIImage?) -> ())
  public func waveformImage(fromAudioAt audioAssetURL: Foundation.URL, size: CoreFoundation.CGSize, backgroundColor: UIKit.UIColor = UIColor.clear, style: PVLib.WaveformStyle = .gradient([UIColor.black, UIColor.darkGray]), position: PVLib.WaveformPosition = .middle, scale: CoreFoundation.CGFloat = UIScreen.main.scale, paddingFactor: CoreFoundation.CGFloat? = nil, qos: Dispatch.DispatchQoS.QoSClass = .userInitiated, shouldAntialias: Swift.Bool = false, completionHandler: @escaping (_ waveformImage: UIKit.UIImage?) -> ())
  @objc deinit
}
public enum WaveformPosition {
  case top
  case middle
  case bottom
  case custom(Swift.Double)
}
public enum WaveformStyle {
  public struct StripeConfig {
    public let color: UIKit.UIColor
    public let width: CoreFoundation.CGFloat
    public let spacing: CoreFoundation.CGFloat
    public let lineCap: CoreGraphics.CGLineCap
    public init(color: UIKit.UIColor, width: CoreFoundation.CGFloat = 1, spacing: CoreFoundation.CGFloat = 5, lineCap: CoreGraphics.CGLineCap = .square)
  }
  case filled(UIKit.UIColor)
  case gradient([UIKit.UIColor])
  case striped(PVLib.WaveformStyle.StripeConfig)
}
public struct WaveformConfiguration {
  public init(size: CoreFoundation.CGSize, backgroundColor: UIKit.UIColor = UIColor.clear, style: PVLib.WaveformStyle = .gradient([UIColor.black, UIColor.gray]), position: PVLib.WaveformPosition = .middle, scale: CoreFoundation.CGFloat = UIScreen.main.scale, paddingFactor: CoreFoundation.CGFloat? = nil, shouldAntialias: Swift.Bool = false)
}
public enum LightType : Swift.UInt32 {
  case ambient
  case directional
  case omni
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
public class Light {
  public var type: PVLib.LightType
  public var color: Swift.SIMD3<Swift.Float>
  public var intensity: Swift.Float
  public init()
  public var worldTransform: simd.simd_float4x4
  public var position: Swift.SIMD3<Swift.Float> {
    get
  }
  public var direction: Swift.SIMD3<Swift.Float> {
    get
  }
  public var castsShadows: Swift.Bool
  public var shadowTexture: (any Metal.MTLTexture)?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VExport {
  public static func export(presetName: Swift.String, inVideoUrl: Foundation.URL!, inAudioUrl: Foundation.URL!, outUrl: Foundation.URL!, completion: @escaping () -> Swift.Void)
  public static var progress: Swift.Float? {
    get
    set(newVal)
  }
  public static func exportPB(presetName: Swift.String, inVideoUrl: Foundation.URL!, outUrl: Foundation.URL!, completion: @escaping () -> Swift.Void)
  public static func saveMovieToCameraRoll(videoURL: Foundation.URL, tru: Swift.Bool = false)
  public static func videoCompositionInstruction(_ track: AVFoundation.AVCompositionTrack) -> AVFoundation.AVMutableVideoCompositionLayerInstruction
  public static func trim(inURL: Foundation.URL, outURL: Foundation.URL, timeRange: CoreMedia.CMTimeRange, callBack: @escaping () -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class HVController : SwiftUI.UIHostingController<SwiftUI.AnyView> {
  @_Concurrency.MainActor(unsafe) public var shouldRotate: Swift.Bool
  @_Concurrency.MainActor(unsafe) public init(shouldRotate: Swift.Bool, rootView: SwiftUI.AnyView)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var shouldAutorotate: Swift.Bool {
    @objc get
  }
  @objc deinit
}
public struct SupportedOrientationsPreferenceKey : SwiftUI.PreferenceKey {
  public typealias Value = UIKit.UIInterfaceOrientationMask
  public static var defaultValue: UIKit.UIInterfaceOrientationMask {
    get
  }
  public static func reduce(value: inout UIKit.UIInterfaceOrientationMask, nextValue: () -> UIKit.UIInterfaceOrientationMask)
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class OrientationLockedController<Content> : SwiftUI.UIHostingController<PVLib.OrientationLockedController<Content>.Root<Content>> where Content : SwiftUI.View {
  public class Box {
    public init()
    @objc deinit
  }
  @_Concurrency.MainActor(unsafe) public var orientations: PVLib.OrientationLockedController<Content>.Box!
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public init(rootView: Content)
  public struct Root<Content> : SwiftUI.View where Content : SwiftUI.View {
    @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s5PVLib27OrientationLockedControllerC4RootV4bodyQrvp", 0) __<Content, Content>
  }
  @objc deinit
}
extension SwiftUI.View {
  public func supportedOrientations(_ supportedOrientations: UIKit.UIInterfaceOrientationMask) -> some SwiftUI.View
  
}
public protocol MultiPBufferDelegate : AnyObject {
  func updatePixelBuffer(front: CoreVideo.CVPixelBuffer, back: CoreVideo.CVPixelBuffer, timestampFull: CoreMedia.CMTime, timestampIcon: CoreMedia.CMTime?)
}
public enum CamPos {
  case back, front
  public static func == (a: PVLib.CamPos, b: PVLib.CamPos) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers final public class PVMultiCamCaptureManager : ObjectiveC.NSObject, AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  public static let shared: PVLib.PVMultiCamCaptureManager
  final public var camPos: PVLib.CamPos
  weak final public var delegate: (any PVLib.MultiPBufferDelegate)?
  final public let session: AVFoundation.AVCaptureMultiCamSession
  @objc override dynamic public init()
  final public func startSession()
  @objc deinit
  final public func switchLight()
  final public func pauseSession()
  final public func resumeSession()
  final public func stopCaptureSession()
  @objc final public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc final public func captureOutput(_ captureOutput: AVFoundation.AVCaptureOutput, didDrop sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
@_hasMissingDesignatedInitializers public class MFManager {
  public static var imagesPath: Foundation.URL? {
    get
  }
  public static var gifFiltersPath: Foundation.URL? {
    get
  }
  public static var resPath: Foundation.URL {
    get
  }
  public static var inAudio: Foundation.URL
  public static var musicFile: Foundation.URL
  public static var audioFile: Foundation.URL
  public static var sourceUrlVal: Foundation.URL
  public static var sourceUrl: Foundation.URL {
    get
    set
  }
  public static var exportedUrl: Foundation.URL
  public static var textUrl: Foundation.URL
  public static var previewFile: Foundation.URL
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class DragRotateScaleView : UIKit.UIView {
  @objc deinit
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any PVLib.DragRotateScaleViewDelegate)?
  @_Concurrency.MainActor(unsafe) public var rotation: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) public func rotated(by deg: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class TextDRSView : PVLib.DragRotateScaleView {
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) override public func rotated(by deg: CoreFoundation.CGFloat)
}
public protocol DragRotateScaleViewDelegate : AnyObject {
  func willPanGesture(_ sender: UIKit.UIPanGestureRecognizer, view: PVLib.DragRotateScaleView)
  func didPanGesture(_ sender: UIKit.UIPanGestureRecognizer, view: PVLib.DragRotateScaleView)
  func willPinchGesture(_ sender: UIKit.UIPinchGestureRecognizer, view: PVLib.DragRotateScaleView)
  func didPinchGesture(_ sender: UIKit.UIPinchGestureRecognizer, view: PVLib.DragRotateScaleView)
  func willRotateGesture(_ sender: UIKit.UIRotationGestureRecognizer, view: PVLib.DragRotateScaleView)
  func didRotateGesture(_ sender: UIKit.UIRotationGestureRecognizer, view: PVLib.DragRotateScaleView)
  func doubleTapGesture(_ sender: UIKit.UITapGestureRecognizer, view: PVLib.DragRotateScaleView)
  func longPressGesture(_ sender: UIKit.UILongPressGestureRecognizer, view: PVLib.DragRotateScaleView)
}
extension PVLib.DragRotateScaleViewDelegate {
  public func willPanGesture(_ sender: UIKit.UIPanGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func didPanGesture(_ sender: UIKit.UIPanGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func willPinchGesture(_ sender: UIKit.UIPinchGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func didPinchGesture(_ sender: UIKit.UIPinchGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func willRotateGesture(_ sender: UIKit.UIRotationGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func didRotateGesture(_ sender: UIKit.UIRotationGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func doubleTapGesture(_ sender: UIKit.UITapGestureRecognizer, view: PVLib.DragRotateScaleView)
  public func longPressGesture(_ sender: UIKit.UILongPressGestureRecognizer, view: PVLib.DragRotateScaleView)
}
public class Device {
  public static let shared: PVLib.Device
  final public let device: any Metal.MTLDevice
  @objc deinit
  public init()
  final public func newCommandBuffer() -> any Metal.MTLCommandBuffer
  final public class func renderPipe(vertexFunctionName: Swift.String = "vertexShader", fragmentFunctionName: Swift.String, pixelFormat: Metal.MTLPixelFormat) throws -> any Metal.MTLRenderPipelineState
  final public class func texture(_ size: CoreFoundation.CGSize) -> (any Metal.MTLTexture)?
  final public class func textureA(_ width: Swift.Int, _ height: Swift.Int) -> (any Metal.MTLTexture)?
  final public class func filerTexture(_ width: Swift.Int, _ height: Swift.Int) -> (any Metal.MTLTexture)?
  final public class func vertexBuffer() -> (any Metal.MTLBuffer)?
  final public func ciTextures(_ imgs: [CoreImage.CIImage], size: CoreFoundation.CGSize, commandBuff: any Metal.MTLCommandBuffer) -> (any Metal.MTLTexture)?
}
extension Metal.MTLRenderCommandEncoder {
  public func setVertexValue<T>(_ value: T, at index: Swift.Int)
  public func setVertexValue<T>(_ value: [T], at index: Swift.Int)
  public func setFragmentValue<T>(_ value: T, at index: Swift.Int)
  public func setFragmentValue<T>(_ value: [T], at index: Swift.Int)
  public func setVertexTextures(_ textures: [(any Metal.MTLTexture)?], startingAt startIndex: Swift.Int = 0)
  public func setVertexTextures(_ textures: (any Metal.MTLTexture)?..., startingAt startIndex: Swift.Int = 0)
  public func setFragmentTextures(_ textures: [(any Metal.MTLTexture)?], startingAt startIndex: Swift.Int = 0)
}
public struct CameraProperties {
  public var touches: CoreFoundation.CGPoint
  public var totalTime: CoreFoundation.CGFloat!
  public var frontCam: Swift.Bool
  public var duration: CoreMedia.CMTime!
  public var withMusic: Swift.Bool
  public var supportLidar: Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class PVMetalRenderer : ObjectiveC.NSObject {
  public func mtkView(_ view: MetalKit.MTKView, drawableSizeWillChange size: CoreFoundation.CGSize)
  public var faceDetector: (any PVLib.PVFaceSceneDelegate)?
  public var scnView: SceneKit.SCNView!
  public var mtlUniforms: PVLib.MetalUniforms!
  public var beautyValues: PVLib.BeautyValues!
  public var beautyId: Swift.Int
  public var segment: PVLib.Segment?
  public var metalLayer: QuartzCore.CAMetalLayer
  public var pixelBuffer: CoreVideo.CVPixelBuffer?
  public var pixelIconBuffer: CoreVideo.CVPixelBuffer?
  public var useMultiCam: Swift.Bool
  public var outputTexure: (any Metal.MTLTexture)?
  public var multiCamTexure: (any Metal.MTLTexture)?
  public var fullCamTexure: (any Metal.MTLTexture)?
  public var main_tool_id: Swift.Int
  public var layerVal: Swift.Int
  public var filter: Swift.String {
    get
    set
  }
  public var lutsId: Swift.Int {
    get
    set
  }
  public var mask: PVLib.ARMask {
    get
    set
  }
  @objc deinit
  @objc override dynamic public init()
  public func startDraw()
  public func invalidate()
  public func changeCamera()
  public func stopScene()
  public func setEditorFrame()
  public func setFrame(_ frame: CoreFoundation.CGRect)
  public func updateFrame()
  public func updatePixelBuffer(pixelsFull: CoreVideo.CVPixelBuffer, pixelsIcon: CoreVideo.CVPixelBuffer? = nil, timestampFull: CoreMedia.CMTime? = nil, timestampIcon: CoreMedia.CMTime? = nil)
  public func renderer()
  public func editDraw(sourceBuffer source: CoreVideo.CVPixelBuffer, cTime: CoreMedia.CMTime)
}
extension CoreFoundation.CGPoint {
  public func convert(rect: CoreFoundation.CGRect) -> simd.float2
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class AudioNode : PVLib.NodeView {
  @_Concurrency.MainActor(unsafe) public var scale: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var timeLinePos: CoreMedia.CMTime
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func setupSound(audioURL: Foundation.URL)
}
public protocol TrimmerDelegate : AnyObject {
  func didChangePositionBar(_ playerTime: CoreMedia.CMTime)
  func positionBarStoppedMoving(_ playerTime: CoreMedia.CMTime)
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class TrimmerView : UIKit.UIView, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) public var moving: Swift.Bool
  @objc deinit
  @_Concurrency.MainActor(unsafe) public var id: Swift.Int?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var mainColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var handleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var positionBarColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var maskColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var isSelected: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public let trimView: UIKit.UIImageView
  @_Concurrency.MainActor(unsafe) public var assetDuration: CoreMedia.CMTime!
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any PVLib.TrimmerDelegate)?
  @_Concurrency.MainActor(unsafe) public func setupSubviews()
  @_Concurrency.MainActor(unsafe) public var asset: AVFoundation.AVAsset? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func assetDidChange(newAsset: AVFoundation.AVAsset?)
  @_Concurrency.MainActor(unsafe) public func setupAssetPreview()
  @_Concurrency.MainActor(unsafe) public func constrainAssetPreview()
  @_Concurrency.MainActor(unsafe) public func setupTrimmerView()
  @_Concurrency.MainActor(unsafe) public func effectsView()
  @_Concurrency.MainActor(unsafe) public func seek(to time: Foundation.TimeInterval)
  @_Concurrency.MainActor(unsafe) public func seek(to time: CoreMedia.CMTime)
  @_Concurrency.MainActor(unsafe) public var updateRightHandler: Swift.Bool
  @_Concurrency.MainActor(unsafe) public func resetHandleViewPosition()
  @_Concurrency.MainActor(unsafe) public var startTime: CoreMedia.CMTime? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var timeRange: CoreMedia.CMTimeRange
  @_Concurrency.MainActor(unsafe) public var endTime: CoreMedia.CMTime? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_hasMissingDesignatedInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class NodeView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var moving: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @objc deinit
  @_Concurrency.MainActor(unsafe) public var id: Swift.Int
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var mainColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var backColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var waveformView: UIKit.UIImageView
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var handleColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var positionBarColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var maskColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var isSelected: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var selected: Swift.Bool {
    get
    set(val)
  }
  @_Concurrency.MainActor(unsafe) final public let trimView: UIKit.UIImageView
  @_Concurrency.MainActor(unsafe) public var assetDuration: CoreMedia.CMTime!
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any PVLib.TrimmerDelegate)?
  @_Concurrency.MainActor(unsafe) public func setupSubviews()
  @_Concurrency.MainActor(unsafe) public func addImage(image: UIKit.UIImage)
  @_Concurrency.MainActor(unsafe) public func setupTrimmerView()
  @_Concurrency.MainActor(unsafe) public func effectsView()
  @_Concurrency.MainActor(unsafe) public func seek(to time: Foundation.TimeInterval)
  @_Concurrency.MainActor(unsafe) public func seek(to time: CoreMedia.CMTime)
  @_Concurrency.MainActor(unsafe) public func resetHandleViewPosition()
  @_Concurrency.MainActor(unsafe) public var startTime: CoreMedia.CMTime? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var timeRange: CoreMedia.CMTimeRange
  @_Concurrency.MainActor(unsafe) public var endTime: CoreMedia.CMTime? {
    get
  }
}
@_hasMissingDesignatedInitializers public class BottleState {
  public var position: Swift.SIMD3<Swift.Float>
  public var scale: Swift.Float
  public var rotationAxis: Swift.SIMD3<Swift.Float>
  public var rotationAngle: Swift.Float
  public var angularVelocity: Swift.Float
  @objc deinit
}
public struct InstanceConstants {
  public var modelMatrix: simd.float4x4
}
public struct FrameConstants {
  public var projectionMatrix: simd.float4x4
  public var viewMatrix: simd.float4x4
  public var lightCount: Swift.UInt32
}
public struct LightConstants {
  public var viewProjectionMatrix: simd.simd_float4x4
  public var intensity: simd.simd_float3
  public var position: simd.simd_float3
  public var direction: simd.simd_float3
  public var type: Swift.UInt32
}
public func align(_ value: Swift.Int, upTo alignment: Swift.Int) -> Swift.Int
public func gcd(_ m: Swift.Int, _ n: Swift.Int) -> Swift.Int
public func lcm(_ m: Swift.Int, _ n: Swift.Int) -> Swift.Int
extension Swift.SIMD4 {
  public var xyz: Swift.SIMD3<Scalar> {
    get
  }
}
extension simd.simd_float4x4 {
  public init(scale2D s: Swift.SIMD2<Swift.Float>)
  public init(rotateZ zRadians: Swift.Float)
  public init(translate2D t: Swift.SIMD2<Swift.Float>)
  public init(scale s: Swift.SIMD3<Swift.Float>)
  public init(rotateAbout axis: Swift.SIMD3<Swift.Float>, byAngle radians: Swift.Float)
  public init(translate t: Swift.SIMD3<Swift.Float>)
  public init(lookAt at: Swift.SIMD3<Swift.Float>, from: Swift.SIMD3<Swift.Float>, up: Swift.SIMD3<Swift.Float>)
  public init(orthographicProjectionWithLeft left: Swift.Float, top: Swift.Float, right: Swift.Float, bottom: Swift.Float, near: Swift.Float, far: Swift.Float)
  public init(perspectiveProjectionFoVY fovYRadians: Swift.Float, aspectRatio: Swift.Float, near: Swift.Float, far: Swift.Float)
}
public struct Gifson : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Vfxson : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PVToolset : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PVGifItem {
}
public struct ExportFilters {
}
public struct ExportText {
}
public struct GifItem {
  public var timeRange: CoreMedia.CMTimeRange?
  public var transformCA: CoreFoundation.CGAffineTransform!
  public var transformCAExport: CoreFoundation.CGAffineTransform!
  public var transformDRSView: CoreFoundation.CGAffineTransform!
  public var frameDuration: Swift.Double!
  public var imageSize: CoreFoundation.CGSize!
  public var gif: [UIKit.UIImage]?
  public var type: PVLib.Types!
  public var id: Swift.Int
  public init(timeRange: CoreMedia.CMTimeRange? = nil, transformCA: CoreFoundation.CGAffineTransform!, transformCAExport: CoreFoundation.CGAffineTransform! = CGAffineTransform(), transformDRSView: CoreFoundation.CGAffineTransform! = CGAffineTransform(), frameDuration: Swift.Double!, imageSize: CoreFoundation.CGSize!, gif: [UIKit.UIImage]? = nil, type: PVLib.Types!, id: Swift.Int)
}
public enum Types {
  case gif, text
  public static func == (a: PVLib.Types, b: PVLib.Types) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class EditModel {
  public init()
  public static var longPressFilters: [PVLib.ExportFilters]
  public static var gifItems: [PVLib.GifItem]
  public static var gifTextures: PVLib.GifTextures
  public static var trimmerRange: CoreMedia.CMTimeRange
  public static var trimm: Swift.Bool
  public static func reset()
  @objc deinit
}
public struct GifTextures {
  public var texture: [any Metal.MTLTexture]
  public var size: [CoreFoundation.CGSize]
}
@_hasMissingDesignatedInitializers public class PVConstructor {
  public static var toolset: PVLib.PVToolset
  public static func initEditor() -> Swift.String?
  public func loadIcons(images: inout [UIKit.UIImage], for icons: Swift.String)
  public static func loadGifs()
  public static func constructGifData(_ data: Foundation.Data) -> [UIKit.UIImage]
  public static func loadGifIcons()
  @objc deinit
}
public enum SoundCategory {
  case ambient
  case soloAmbient
  case playback
  case record
  case playAndRecord
  public static func == (a: PVLib.SoundCategory, b: PVLib.SoundCategory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class Sound {
  public static var playersPerSound: Swift.Int {
    get
    set
  }
  public static var session: any PVLib.Session
  public static var category: PVLib.SoundCategory {
    get
    set
  }
  public static var enabled: Swift.Bool {
    get
    set
  }
  public static var playerClass: any PVLib.Player.Type
  public static var soundsBundle: Foundation.Bundle
  public init?(url: Foundation.URL)
  @objc deinit
  @discardableResult
  public func play(numberOfLoops: Swift.Int = 0, completion: PVLib.PlayerCompletion? = nil) -> Swift.Bool
  public func stop()
  public func pause()
  @discardableResult
  public func resume() -> Swift.Bool
  public var playing: Swift.Bool {
    get
  }
  public var paused: Swift.Bool {
    get
  }
  @discardableResult
  public func prepare() -> Swift.Bool
  @discardableResult
  public static func play(file: Swift.String, fileExtension: Swift.String? = nil, numberOfLoops: Swift.Int = 0) -> Swift.Bool
  @discardableResult
  public static func play(url: Foundation.URL, numberOfLoops: Swift.Int = 0) -> Swift.Bool
  public static func stop(for url: Foundation.URL)
  public var duration: Foundation.TimeInterval {
    get
  }
  public var volume: Swift.Float {
    get
    set
  }
  public var time: Swift.Double {
    get
    set
  }
  public static func stop(file: Swift.String, fileExtension: Swift.String? = nil)
  public static func stopAll()
}
public protocol Player : AnyObject {
  func play(numberOfLoops: Swift.Int, completion: PVLib.PlayerCompletion?) -> Swift.Bool
  func stop()
  func pause()
  func resume()
  func prepareToPlay() -> Swift.Bool
  init(contentsOf url: Foundation.URL) throws
  var duration: Foundation.TimeInterval { get }
  var volume: Swift.Float { get set }
  var time: Swift.Double { get set }
  var isPlaying: Swift.Bool { get }
}
public typealias PlayerCompletion = ((Swift.Bool) -> ())
extension AVFAudio.AVAudioPlayer : PVLib.Player, AVFAudio.AVAudioPlayerDelegate {
  public func play(numberOfLoops: Swift.Int, completion: PVLib.PlayerCompletion?) -> Swift.Bool
  public var time: Swift.Double {
    get
    set
  }
  public func resume()
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
  @objc dynamic public func audioPlayerDecodeErrorDidOccur(_ player: AVFAudio.AVAudioPlayer, error: (any Swift.Error)?)
}
public protocol Session : AnyObject {
  func setCategory(_ category: AVFAudio.AVAudioSession.Category) throws
}
extension AVFAudio.AVAudioSession : PVLib.Session {
}
public class Load {
  public init()
  public static var soundIcons: [UIKit.UIImage] {
    get
  }
  public static var lutsIcons: [UIKit.UIImage] {
    get
  }
  public static var filtersIcons: [UIKit.UIImage] {
    get
  }
  public static var gifLayerIcons: [UIKit.UIImage] {
    get
  }
  public static var masksIcons: [UIKit.UIImage] {
    get
  }
  public static var shadersIcons: [UIKit.UIImage] {
    get
  }
  public static var timerIcons: [UIKit.UIImage] {
    get
  }
  public static var speedIcons: [UIKit.UIImage] {
    get
  }
  public static var beautyIcons: [UIKit.UIImage] {
    get
  }
  public static func fontTexture(loader: MetalKit.MTKTextureLoader) -> (any Metal.MTLTexture)?
  @objc deinit
}
public protocol PBufferDelegate : AnyObject {
  func updatePixelBuffer(camera: CoreVideo.CVPixelBuffer, timestamp: CoreMedia.CMTime)
}
@_hasMissingDesignatedInitializers public class Segment {
  @objc deinit
}
public class WaveformAnalyzer {
  public var duration: Swift.Double!
  public init?(audioAssetURL: Foundation.URL)
  public func samples(count: Swift.Int, qos: Dispatch.DispatchQoS.QoSClass = .userInitiated, completionHandler: @escaping (_ amplitudes: [Swift.Float]?) -> ())
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AssetModel {
  public static var land: Swift.Bool
  public static var rotation: Swift.Float
  public static var rotationGif: Swift.Float
  public static var aspectRatio: CoreFoundation.CGFloat
  public static var drawableSize: CoreFoundation.CGSize
  public static var exportSize: CoreFoundation.CGSize
  public static var exportPoint: CoreFoundation.CGPoint
  public static var orientation: UIKit.UIDeviceOrientation
  public static var viewField: Swift.Float
  public static var layerVal: Swift.Int
  public static var lutsId: Swift.Int
  public static var filter: PVLib.EditFXs
  public static var fx: Swift.String
  public static var mask: PVLib.ARMask
  public static var duration: CoreMedia.CMTime!
  public static var done: Swift.Bool
  public static var recorded: Swift.Bool
  public static var maxFrameDuration: Swift.Double
  public static var minFrameDuration: Swift.Double
  public static func resetAll()
  @objc deinit
}
extension UIKit.UIImage {
  public class func constructGifData(_ data: Foundation.Data) -> [UIKit.UIImage]
}
extension UIKit.UIImage {
  public class func gifImageWithData(_ data: Foundation.Data) -> UIKit.UIImage?
  public class func gifImageWithURL(_ gifUrl: Swift.String) -> UIKit.UIImage?
  public class func gifImageWithName(_ name: Swift.String) -> UIKit.UIImage?
}
extension PVLib.ARMask : Swift.Equatable {}
extension PVLib.ARMask : Swift.Hashable {}
extension PVLib.ARMask : Swift.RawRepresentable {}
extension PVLib.BeautyFilters : Swift.Equatable {}
extension PVLib.BeautyFilters : Swift.Hashable {}
extension PVLib.BeautyFilters : Swift.RawRepresentable {}
extension PVLib.CamFXs : Swift.Equatable {}
extension PVLib.CamFXs : Swift.Hashable {}
extension PVLib.CamFXs : Swift.RawRepresentable {}
extension PVLib.EditFXs : Swift.Equatable {}
extension PVLib.EditFXs : Swift.Hashable {}
extension PVLib.EditFXs : Swift.RawRepresentable {}
extension PVLib.MultiPassFXs : Swift.Equatable {}
extension PVLib.MultiPassFXs : Swift.Hashable {}
extension PVLib.MultiPassFXs : Swift.RawRepresentable {}
extension PVLib.CamEffectType : Swift.Equatable {}
extension PVLib.CamEffectType : Swift.Hashable {}
extension PVLib.CamEffectType : Swift.RawRepresentable {}
extension PVLib.MainTools : Swift.Equatable {}
extension PVLib.MainTools : Swift.Hashable {}
extension PVLib.MainTools : Swift.RawRepresentable {}
extension PVLib.LayerTypes : Swift.Equatable {}
extension PVLib.LayerTypes : Swift.Hashable {}
extension PVLib.LayerTypes : Swift.RawRepresentable {}
extension PVLib.MainVideoEditingTools : Swift.Equatable {}
extension PVLib.MainVideoEditingTools : Swift.Hashable {}
extension PVLib.MainVideoEditingTools : Swift.RawRepresentable {}
extension PVLib.FrameAlignment : Swift.Equatable {}
extension PVLib.FrameAlignment : Swift.Hashable {}
extension PVLib.LightType : Swift.Equatable {}
extension PVLib.LightType : Swift.Hashable {}
extension PVLib.LightType : Swift.RawRepresentable {}
extension PVLib.CamPos : Swift.Equatable {}
extension PVLib.CamPos : Swift.Hashable {}
extension PVLib.Types : Swift.Equatable {}
extension PVLib.Types : Swift.Hashable {}
extension PVLib.SoundCategory : Swift.Equatable {}
extension PVLib.SoundCategory : Swift.Hashable {}
